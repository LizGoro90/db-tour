package main

import (
	"log"

	"upper.io/db.v3/postgresql"
)

var settings = postgresql.ConnectionURL{
	Database: `booktown`,
	Host:     `demo.upper.io`,
	User:     `demouser`,
	Password: `demop4ss`,
}

// Book represents an item from the "books" table.
type Book struct {
	// If your table is configured to autogenerate IDs, you must use the
	// "omitempty" option.
	ID    uint   `db:"id,omitempty"`
	Title string `db:"title"`
	// You can also use omitempty on any other field that you'd rather not use on
	// a query if it has the zero value.
	AuthorID  uint `db:"author_id,omitempty"`
	SubjectID uint `db:"subject_id,omitempty"`
}

func main() {
	sess, err := postgresql.Open(settings)
	if err != nil {
		log.Fatal("Open: ", err)
	}
	defer sess.Close()

	sess.SetLogging(true)

	booksTable := sess.Collection("books")

	book := Book{
		Title:    "Kokoro",
		AuthorID: 123,
	}

	// The InsertReturning method inserts a new item into the given collection.
	// This method expects a pointer to a struct or a map. If the query succeeds,
	// the item gets updated with info from the database, such as autogenerated
	// IDs or timestamps (this depends on how your table is configured).
	// UpdateReturning is similar to InsertReturning, except the latter issues an
	// UPDATE statement instead of an INSERT one.
	err = booksTable.InsertReturning(&book)
	if err != nil {
		log.Printf("InsertReturning: %v\n", err)
		log.Fatal("This is OK, this is a restricted sandbox with a read-only database.")
	}

	log.Printf("Book: %#v", book)
}
